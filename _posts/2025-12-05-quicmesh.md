# Quicmesh — Adaptive Mesh Networking on QUIC

*Why I built it, what it solves, and how it works under the hood.*

Mesh networking is deceptively hard. On paper it’s just nodes sending packets to each other. In practice, it’s NAT traversal, churn, bad connections, asymmetric routes, unpredictable latency, and the endless game of “why can’t these two nodes talk even though they both swear they’re online?”

Over the years I’ve worked with DHTs, NAT traversal stacks, and pub-sub overlays—usually existing in their own silos. So I set out to build **Quicmesh**, a small but complete mesh-networking library in Rust that brings everything together into one coherent stack:

* A **Kademlia-style Distributed Hash Table** for node discovery
* **GossipSub** for efficient topic-based pub/sub
* A full **ICE-like NAT traversal pipeline** (STUN, TURN, hole punching)
* **Latency-aware routing** with k-means clustering
* QUIC transport with **seamless connection migration**
* Strong **cryptographic identities** and Sybil protection

What I wanted was a library that “just forms a network” even under bad real-world conditions—mobile networks, CGNAT, unpredictable paths—while remaining small, fast, and Rust-idiomatic.

Here’s what that looks like.

---

## A Networking Stack Built Around Reality, Not Assumptions

Most meshes assume a world where nodes can directly reach each other. Quicmesh assumes the opposite.

### QUIC as the foundation

The transport layer uses QUIC (via `quinn`). It gives us:

* Fast, encrypted, multiplexed streams
* Connection migration (critical for mobile)
* UDP hole punching compatibility
* TLS identity binding with custom Ed25519 certificates

QUIC turns out to be a perfect substrate for meshes because it performs well in noisy networks and handles path changes gracefully. In a mesh, paths change constantly.

---

## The Discovery Layer: A Smarter Kademlia

Quicmesh ships a Kademlia-style Distributed Hash Table, but with a few modern twists.

### Adaptive bucket sizing (`k`) and lookup parallelism (`α`)

Real networks are dynamic. If churn increases, Quicmesh increases `k`. If lookups fail or time out, it increases `α`. The node tunes itself to the network rather than forcing fixed parameters.

### Latency tiering with k-means clustering

This is heavily inspired by CoralDSHT. Every few minutes, each node clusters node by RTT:

* Fast nodes go in low-latency tiers
* Slow or remote nodes move to higher tiers
* Lookups start in fast tiers, spill into slow tiers only when needed

This keeps routing snappy and makes the DHT scalable even with large node sets.

---

## NAT Traversal: The Full Pipeline

Most NAT traversal codebases do one thing—STUN, or TURN, or ICE-lite. Quicmesh attempts the full pipeline:

```
STUN → NAT type detection → Hole punching → Relay fallback → Direct upgrade
```

### Why so much machinery?

Because NATs are cruel.

* **Full-cone / restricted cone NAT**? Hole punching works fine.
* **Port-restricted cone NAT**? Works with synchronized punching.
* **Symmetric NAT / CGNAT**? Abandon hope; you need a relay.

Quicmesh automatically:

1. Discovers external addresses
2. Publishes them to the DHT as signed endpoint records
3. Performs multi-path probing and connectivity checks
4. Falls back to TURN-style relay when needed
5. Continues probing direct paths in the background
6. Migrates the QUIC connection if a better path appears

This “smart connection” behaviour means two nodes may start relayed but later upgrade to a direct, low-latency path—without reconnecting.

---

## Smart Connections & Path Probing

One of the most fun subsystems in Quicmesh is the **path prober**—a small engine that constantly tests alternate routes and picks the fastest one.

* Direct path suddenly becomes reachable? Switch to it.
* Relay becomes overloaded? Pick a different relay.
* WiFi → 4G network switch? QUIC migrates effortlessly.

The node stays connected even while the network beneath it changes.

---

## GossipSub Pub/Sub Layer

On top of discovery and connections sits a GossipSub implementation (adapted from libp2p’s design but built from scratch):

* Topic-based broadcast
* Epidemic propagation (O(log n) hops)
* Deduplication via LRU cache
* Mesh maintenance (graft/prune)
* IHave/IWant gossip for message reliability

This enables chatrooms, telemetry streams, IoT broadcast channels, and multiplayer game lobbies with very little code.

---

## Identity: Ed25519 + BLAKE3

Node identity is tied to its public key:

```
NodeId = BLAKE3(Ed25519_public_key)
```

This gives:

* Built-in Sybil resistance
* Certificate-to-NodeId binding
* Verifiable endpoint records in the DHT

Every network message is backed by the TLS handshake identity, reducing impersonation attacks.

---

## Putting It Together: The Stack

Here’s the Quicmesh architecture in a nutshell:

```
[ Application Layer ]
  - Discovery, address publishing, resolve_node
[ Discovery Layer ]
  - Kademlia DHT, routing table, tiering
[ Connection Layer ]
  - Smart connections, path probing, connection manager
[ NAT Traversal ]
  - ICE-lite, STUN, TURN, hole punching
[ Transport ]
  - QUIC + Ed25519 TLS certificates
[ Identity ]
  - Ed25519 keypairs, NodeId, signed endpoint records
```

Each layer is modular; you can use the DHT without the pub/sub system, or NAT traversal without GossipSub, depending on your application.

---

## Example: Spinning Up a Node

Creating a node is intentionally simple:

```rust
let keypair = Keypair::generate();
let node_id = keypair.node_id();

let (certs, key) = generate_ed25519_cert(&keypair)?;
let server_config = create_server_config(certs, key)?;
let client_config = create_client_config()?;

let endpoint = Endpoint::server(server_config, "0.0.0.0:0".parse()?)?;
let network = QuinnNetwork::new(endpoint.clone(), self_contact, client_config);

let dht = DiscoveryNode::new(node_id, self_contact, network, 20, 3);
let node = MeshNode::new(dht.clone());

let handle = node.spawn(endpoint);
```

From here you can:

* Publish your address
* Resolve other nodes
* Join a pub/sub topic
* Broadcast messages
* Inspect telemetry

It’s intentionally batteries-included but not overbearing.

---

## Why Build This?

Because I wanted a mesh networking toolkit that:

* Works across NATs and mobile networks
* Uses modern transport (QUIC)
* Adapts to network conditions
* Has clear, verifiable identities
* Stays small and Rust-friendly
* Doesn’t require libp2p’s full complexity

Think of it as: **libp2p’s DHT + WebRTC’s ICE + QUIC + a lightweight GossipSub**, but designed to be hackable and easy to integrate.

---

## What’s Next?

Some things I’m experimenting with:

* QUIC stream priorities for pub/sub
* Relay federation (multi-relay selection & load balancing)
* BBR-inspired congestion feedback
* Request/response RPC layer
* Lightweight content routing (DSHT-style)

If any of this interests you—or if you want to use Quicmesh in a project—feel free to reach out.

You can find the crate here:
**[https://crates.io/crates/quicmesh](https://crates.io/crates/quicmesh)**

And the documentation:
**[https://docs.rs/quicmesh](https://docs.rs/quicmesh)**
